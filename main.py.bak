# import parameters
from Tools import *
import utils
import time
import json

from Amazonia_Legal import *
from Cerrado_Biome import *
# import GAN

import train_source
import train_cyclegan
import evaluate_cyclegan
import evaluate_cyclegan_inference
import train_adapted_target
import test_models




def train_source_model(source, source_args, target, target_args, train_args, global_args):
	# source_args.patches_dimension = train_args.patch_size
	source_args.stride = source_args.train_source_stride
	ready_domain(source, source_args, train_set = True, augmented = True)

	# target_args.patches_dimension = train_args.patch_size
	target_args.stride = target_args.train_source_stride
	ready_domain(target, target_args, train_set = True, augmented = False)
	print(len(target.central_pixels_coor_vl))
	print(len(source.central_pixels_coor_vl))
	
	best_source_model = train_source.train(source, target, train_args, global_args)
	return best_source_model

def train_cyclegan_model(source, source_args, target, target_args, train_args, global_args):
	source_args.patches_dimension = train_args.patch_size
	source_args.stride = source_args.train_source_stride
	ready_domain(source, source_args, train_set = False, cyclegan_set = True)
	
	target_args.patches_dimension = train_args.patch_size
	target_args.stride = target_args.train_source_stride
	ready_domain(target, target_args, train_set = False, cyclegan_set = True)

	train_cyclegan.train(source, target, train_args, global_args)
	trained_models_path = train_args.output_path + '/saved_models/'
	return trained_models_path


def evalutate_cyclegan_model(source, source_args, train_args, global_args, gan_models_path):
	assert gan_models_path != ''
	
	# source_args.patches_dimension = train_args.patch_size
	source_args.stride = source_args.train_source_stride
	ready_domain(source, source_args, train_set = True, augmented = True)

	# best_gan_epoch = evaluate_cyclegan.train(source, source_args, 
	# 	train_args, global_args, gan_models_path)
	best_gan_epoch = evaluate_cyclegan_inference.evaluate(source, source_args, 
		train_args, global_args, gan_models_path)
	return best_gan_epoch

def train_target_model(source, source_args, target, target_args, train_args, 
	train_source_args, global_args, source_model, A2B_gan_model, B2A_gan_model):
	assert source_model.split('.')[-1] == 'pt'
	assert A2B_gan_model.split('.')[-1] == 'pt'
	assert B2A_gan_model.split('.')[-1] == 'pt'
	assert A2B_gan_model != B2A_gan_model
	
	# source_args.patches_dimension = train_args.patch_size
	source_args.stride = source_args.train_source_stride
	ready_domain(source, source_args, train_set = True, augmented = True)
	source.Prepare_GAN_Set(source_args, A2B_gan_model, eval = False, load = False)

	# target_args.patches_dimension = train_args.patch_size
	target_args.stride = target_args.train_source_stride
	ready_domain(target, target_args, train_set = True, augmented = True)
	target.Prepare_GAN_Set(target_args, B2A_gan_model, 	eval = False, load = False)


	theorical_best_target_model = train_adapted_target.train(source, 
		target, train_args, train_source_args, global_args, source_model)
	return theorical_best_target_model

def run_test(source, source_args, target, target_args, test_args, global_args, 
	models, file_name):

	ready_domain(source, source_args, train_set = False, test_set = True)
	ready_domain(target, target_args, train_set = False, test_set = True)

	domains = []
	domains.append(source)
	domains.append(target)

	test_models.test(domains, test_args, global_args, models, file_name)

	return 0
	
	
def main(parameters, file_name = 'parameters.py'):
# if __name__=='__main__':

	total_time = time.time()
	Global = parameters.Global
	models = {}

	# Prepare root path
	if (os.path.isdir(Global.base_path) == False):
		os.makedirs(Global.base_path)
		print('\''+ Global.base_path + '\'' + " path created")
	# Save used parameters
	with open(file_name, "r") as f:
		lines = f.readlines()
		with open(Global.base_path + "/" + file_name.split('.')[0] 
			+ ".txt", "w") as f1:
			for line in lines:
				f1.write(line)

	# Load data and initial preparation
	pa = CERRADO(parameters.PA)
	ro = AMAZON_RO(parameters.RO)

	if parameters.Global.source_domain == "PA":
		source = pa
		source_args = parameters.PA
		target = ro
		target_args = parameters.RO
	else:
		source = ro
		source_args = parameters.RO
		target = pa
		target_args = parameters.PA

	print('[*] Source domain' , type(source))
	print('[*] Target domain' , type(target))

	# Train steps \/

	# # ------ deforestation train on source domain ------
	# best_source_model = train_source_model(source, source_args, target, target_args, 
	# 	parameters.Train_source, Global)
	# source_args.best_source_model = best_source_model

	# print('[*] Best source model' , best_source_model)
	# models["souce"] = best_source_model
	# with open(Global.base_path + "/best_models_paths.json", "w") as f:
	# 	json.dump(models, f)
	# with open(Global.base_path + "/best_source_model_path.json", "w") as f:
	# 	json.dump(best_source_model, f)
	# # ------ end ------


	# # ------ cyclegan training ------
	# gan_models_path = train_cyclegan_model(source, source_args, target, target_args, 
	# 	parameters.Train_cyclegan, Global)
	# # Global.trained_cyclegan_path = gan_models_path
	# print('[*] Cyclegan trained models in', gan_models_path)
	# # ------ end ------
	

	# gan_models_path = Global.default_cyclegan_path + '/saved_models/'
	# # ------ cyclegan evaluation ------
	# best_gan_epoch = evalutate_cyclegan_model(source, source_args, parameters.Evaluate_cyclegan, 
	# 	Global, gan_models_path)
	# A2B_best_gan_model = gan_models_path + Global.base_A2B_name + best_gan_epoch + '.pt'
	# B2A_best_gan_model = gan_models_path + Global.base_B2A_name + best_gan_epoch + '.pt'
	
	# source_args.best_generator = A2B_best_gan_model
	# target_args.best_generator = B2A_best_gan_model

	# print('[*] Best Source to Target GAN', A2B_best_gan_model)
	# print('[*] Best Target to Source GAN', B2A_best_gan_model)
	# gans = [A2B_best_gan_model, B2A_best_gan_model]
	# models["G_A2B"] = A2B_best_gan_model
	# models["G_B2A"] = B2A_best_gan_model
	# with open(Global.base_path + "/best_gans_paths" + "_" + 
	# 	file_name + ".json", "w") as f:
	# 	json.dump(gans, f)
	# with open(Global.base_path + "/best_models_paths.json", "w") as f:
	# 	json.dump(models, f)
	# # ------ end ------


	# # with open(Global.base_path + "/best_models_paths.json", "w") as f:
	# #  	best_source_model = json.load(f)
	# best_source_model = "./tmp/main_test_PA_source/models/source_seg/model_05_54.3000.pt"
	# best_source_model = "./tmp/test_RO_source_2/models/source_seg/model_07_28.2916.pt"
	# with open(Global.base_path + "/best_gans_paths" + "_" +  file_name + 
	# 	".json", "r") as f:
	# 	loaded_gans = json.load(f)
	# # A2B_best_gan_model = loaded_gans[0]
	# # B2A_best_gan_model = loaded_gans[1]
	# A2B_best_gan_model = loaded_gans[1]
	# B2A_best_gan_model = loaded_gans[0]


	# # ------ deforestation train on target domain -----
	# best_source_model = source_args.best_source_model
	# A2B_best_gan_model = source_args.best_generator
	# B2A_best_gan_model = target_args.best_generator

	# print(best_source_model)
	# print(A2B_best_gan_model)
	# print(B2A_best_gan_model)

	# best_target_model = train_target_model(source, source_args, target, target_args, 
	# 	parameters.Train_adapted_target, parameters.Train_source, Global, best_source_model, 
	# 	A2B_best_gan_model, B2A_best_gan_model)
	# # Global.best_target_model = best_model
	# # Global.theorical_best_target_model = theorical_best_model
	# # print('[*] Best target model on source (through validation)', best_model)
	# print('[*] Theorical best model (on target, through validation)', best_target_model)
	# # models["adapted_target"] = best_model
	# models["best_adapted_target"] = best_target_model
	# models["souce"] = best_source_model
	# # with open(Global.base_path + "/best_models_paths.json", "w") as f:
	# # 	json.dump(models, f)
	# with open(Global.base_path + "/best_target_model_path" + "_" + 
	# 	file_name + ".json", "w") as f:
	# 	json.dump(best_target_model, f)
	# # ------ end ------


	# ------ deforestation test with source, best target and theorical best target models ------
	# ------ on source and target images ------
	models["FS_PA"] = './tmp/new_ref_source_PA/models/source_seg/model_31_65.1563.pt'
	models["FS_RO"] = './tmp/new_ref_source_RO/models/source_seg/model_03_20.7114.pt'
	
	# models["FT-RO-G256-E80/130-PIC"] = './targets_2/parameters_1_PA_source_newEval/target_adapted_seg/model_03_16.7512.pt'
	# models["FT-RO-G256-E110/130-P1024"] = './targets_2/parameters_2_PA_source_newEval/target_adapted_seg/model_03_20.4618.pt'
	# models["FT-RO-G64-E230/401-PIC"] = './targets_2/parameters_3_PA_source_newEval/target_adapted_seg/model_03_20.0562.pt'
	# models["FT-RO-G64-E300/401-P256"] = './targets_2/parameters_4_PA_source_newEval/target_adapted_seg/model_02_22.5629.pt'
	# models["FT-RO-G64-E400/401-P1024"] = './targets_2/parameters_5_PA_source_newEval/target_adapted_seg/model_14_20.6647.pt'

	# models["FT-PA-G256-E80/130-PIC"] = './targets_2/parameters_1_RO_source_newEval/target_adapted_seg/model_10_46.8945.pt'
	# models["FT-PA-G256-E130/130-P1024"] = './targets_2/parameters_2_RO_source_newEval/target_adapted_seg/model_09_45.1766.pt'
	# models["FT-PA-G64-E150/401-PIC"] = './targets_2/parameters_3_RO_source_newEval/target_adapted_seg/model_11_49.6336.pt'
	# models["FT-PA-G64-E150/401-P256"] = './targets_2/parameters_4_RO_source_newEval/target_adapted_seg/model_10_46.1817.pt'
	# models["FT-PA-G64-E150/401-P1024"] = './targets_2/parameters_5_RO_source_newEval/target_adapted_seg/model_04_43.2084.pt'


	models['FT-RO-G256-E80_130-PIC'] = './targets_2/parameters_1_PA_source_Infe/target_adapted_seg/model_02_16.5906.pt'
	models['FT-RO-G256-E130_130-P1024'] = './targets_2/parameters_2_PA_source_Infe/target_adapted_seg/model_01_20.4877.pt'
	models['FT-RO-G64-E400_401-PIC'] = './targets_2/parameters_3_PA_source_Infe/target_adapted_seg/model_08_21.0334.pt'
	models['FT-RO-G64-E370_401-P256'] = './targets_2/parameters_4_PA_source_Infe/target_adapted_seg/model_02_20.2679.pt'
	models['FT-RO-G64-E110_401-P1024'] = './targets_2/parameters_5_PA_source_Infe/target_adapted_seg/model_09_20.9963.pt'

	models['FT-PA-G256-E60_130-PIC'] = './targets_2/parameters_1_RO_source_Infe/target_adapted_seg/model_04_41.8341.pt'
	models['FT-PA-G256-E130_130-P1024'] = './targets_2/parameters_2_RO_source_Infe/target_adapted_seg/model_14_39.3142.pt'
	models['FT-PA-G64-E100_401-PIC'] = './targets_2/parameters_3_RO_source_Infe/target_adapted_seg/model_24_37.4915.pt'
	models['FT-PA-G64-E370_401-P256'] = './targets_2/parameters_4_RO_source_Infe/target_adapted_seg/model_08_40.4374.pt'
	models['FT-PA-G64-E220_401-P1024'] = './targets_2/parameters_5_RO_source_Infe/target_adapted_seg/model_08_39.4405.pt'


	models['FT-RO-G256-E130_130-PIC'] = './targets_2/parameters_1_PA_source/target_adapted_seg/model_02_20.0709.pt'
	models['FT-RO-G256-E130_130-P1024'] = './targets_2/parameters_2_PA_source/target_adapted_seg/model_07_20.7655.pt'
	models['FT-RO-G64-E401_401-PIC'] = './targets_2/parameters_3_PA_source/target_adapted_seg/model_05_20.5934.pt'
	models['FT-RO-G64-E401_401-P256'] = './targets_2/parameters_4_PA_source/target_adapted_seg/model_02_22.3017.pt'
	models['FT-RO-G64-E401_401-P1024'] = './targets_2/parameters_5_PA_source/target_adapted_seg/model_04_21.2095.pt'

	models['FT-PA-G256-E130_130-PIC'] = './targets_2/parameters_1_RO_source/target_adapted_seg/model_14_47.4135.pt'
	models['FT-PA-G256-E130_130-P1024'] = './targets_2/parameters_2_RO_source/target_adapted_seg/model_22_50.1451.pt'
	models['FT-PA-G64-E401_401-PIC'] = './targets_2/parameters_3_RO_source/target_adapted_seg/model_07_47.7287.pt'
	models['FT-PA-G64-E401_401-P256'] = './targets_2/parameters_4_RO_source/target_adapted_seg/model_12_47.9375.pt'
	models['FT-PA-G64-E401_401-P1024'] =  './targets_2/parameters_5_RO_source/target_adapted_seg/model_06_45.7847.pt'

	run_test(source, source_args, target, target_args, parameters.Test_models, Global, models, file_name)
	# ------ end ------






	## ------ Total time calculation ------
	total_time = time.time() - total_time
	if (total_time > 3600):
		print("{:.2f} hours".format(round(total_time/3600, 2)))
	elif (total_time > 60):
		print("{:.2f}minutes".format(round(total_time/60, 2)))
	else:
		print("{:.2f} seconds".format(round(total_time, 2)))


